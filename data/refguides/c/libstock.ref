<library>
General Utilities
stock
-lposix4 -lnsl -lsocket -lm
STOCKLIBS
stock.h
implements variety of general purpose programming utilities

<subsection Parameter Files>
<cdeclarations>
int pfread ( char *name, Pf **pf )
    read parameter space name into pf, returning 0 for success.

int pfupdate ( char *name, Pf **pf )
    check files which compose parameter space name, reread and return 1 if changed;
    on first read, pf must = 0 

Tbl *pffiles ( char *name, int all )
    return list of files which compose name

int pfload ( char *env, char *dir, char *fname, Pf **pf )
    read single parameter file found by datapath(3) into pf

int pfcompile ( char *s, Pf **pf )
    read parameter space from string s into pf

int pfwrite ( char *fname, Pf *pf )
    write parameter space pf to the file fname

int pfin ( FILE *in, Pf **pf )
    read parameter space from file in into pf

int pfout ( FILE *out, Pf *pf )
    write parameter space pf to file out

char *pf2string ( Pf *pf )
    return new string representation of pf 

Pf *pfnew ( int type )
    start a new parameter space

void pffree ( Pf *pf )
    free resources for pf

Pf *pfdel( Pf *pf, char *name)
    remove branch for name from pf, returning the deleted branch

int pfconfig ("ask", char *(*askx)(char *))
    replace default &ask routine with new version askx

int pfget ( Pf *pf, char *name, void **result )
    put value for name from pf in result, returning type

int pfresolve ( Pf *pf, char *name, int create, Pf **result )
    put value for name from pf into result, allowing extended syntax
    like arr{name}[3], returning type

int pfeval ( Pf *pf, char *name, char **result )
    put value for name from pf into result, allowing extended syntax
    like arr{name}[3], but returning only scalar values

int pfget_boolean ( Pf *pf, char *name )
    return boolean value for name from pf

double pfget_double ( Pf *pf, char *name )
    return double value for name from pf

long pfget_int ( Pf *pf, char *name )
    return integer value for name from pf

char *pfget_string ( Pf *pf, char *name )
    return string value for name from pf
    
double pfget_time(Pf *pf, char *name)
    return epoch time for name from pf

double pfget_size(Pf *pf, char *name)
    return size for name from pf, interpreting suffix of
    G (10^9), M (10^6), or k (10^3)

Tbl *pfkeys ( Pf *arr )
    return list of keys for pf arr

Arr *pfget_arr ( Pf *pf, char *name )
    return array value for name from pf

Tbl *pfget_tbl ( Pf *pf, char *name )
    return list value for name from pf

long pfmaxtbl ( Pf *list )
    return the number of elements in the pf list

void pfput ( Pf *pf, char *name, void *value, int t )
    put a value (of type t) into pf under name

int pfset ( Pf *pf, char *name, char *value )
    put a character value into pf under name,
    allowing extended syntax like arr{name}[3]

void pfput_boolean ( Pf *pf, char *name, int value )
    put boolean value into pf under name 

void pfput_double ( Pf *pf, char *name, double value )
    put double value into pf under name 

void pfput_int ( Pf *pf, char *name, long value )
    put integer value into pf under name 

void pfput_string ( Pf *pf, char *name, char *value )
    put string value into pf under name 

void pfput_time(Pf *pf, char *name, double time)
    put readable time into pf under name 

void pfput_arr ( Pf *pf, char *name, Arr *value )
    put array value into pf under name 

void pfput_tbl ( Pf *pf, char *name, Tbl *value )
    put list value into pf under name 

int pfcmp(Pf *pf1, Pf *pf2)
    return 0 if pf1 and pf2 are identical, 1 otherwise

Pf *pfdup(Pf *old)
    duplicates(clones) a parameter file space

int pfrequire(char *pfname, char *atime )
    require pf_revision_code later than atime

<subsection Associative Arrays>
<cdeclarations>
Arr *newarr ( int (*cmp)(char *, char *) )
    create a new associative array with string compare routine cmp;
    if cmp=0, use strcmp().

Arr *duparr(Arr *arr, void *(*adup)(void *))
    return duplicate (clone) of the array arr using the adup routine to duplicate individual values.

int freearr ( Arr *arr, void (*afree)(void *) )
    free array arr, calling afree on each value of the array

void *setarr ( Arr *arr, char *key, void *val )
    set the value for key in arr to val, returning previous value

void *getarr ( Arr *arr, char *key )
    return the value for key in arr 

void *delarr ( Arr *arr, char *key )
    delete the key, value pair for key in arr, returning value 

long cntarr ( Arr *arr )
    return the number of key, value pairs in arr

Tbl *keysarr ( Arr *arr )
    return list of all the keys in arr

Tbl *valsarr ( Arr *arr )
    return list of all the values in arr

int applyarr ( Arr *arr, void (*f) (char *key, void *value, void *p), void *p)
    apply function f to each key, value pair in arr

Tbl *arrgrep ( Arr *arr, char *s )
    match each key of arr as a regular expression against string s, returning list matching keys 

Tbl *greparr ( char *re, Arr *arr )
    return list of all keys in arr which match regular expression re

<subsection Lists>
<cdeclarations>
Tbl *newtbl ( long n )
    return a new list with n elements

Tbl *inittbl ( long left, long right, int direct, void *null, int sz )
    return a new direct list with specified null value and elements of sz bytes

void freetbl ( Tbl *tbl, void (*tfree)(void *) )
    free memory used by list tbl, calling tfree on each element

long maxtbl ( Tbl *tbl )
    return number of elements in list tbl

Tbl *duptbl(Tbl *tbl, void *(*tdup)(void *))
    return duplicate (clone) of the list tbl using the tdup routine to duplicate individual elements.

void clrtbl ( Tbl *tbl, void (*tfree)(void *) )
    empty an existing list tbl, calling tfree on each element

void trunctbl ( Tbl *tbl, long last, void (*tfree)(void *) )
    shorten a list tbl to contain only last elements, calling tfree on other elements 

long settbl ( Tbl *tbl, long index, void *value )
    set element #index of list tbl to value

void *gettbl ( Tbl *tbl, long index )
    return value for element #index of list tbl

long instbl ( Tbl *tbl, long index, void *value )
    insert element value at position index of list tbl, shifting other element to the right

void *deltbl ( Tbl *tbl, long index )
    delete element #index from list tbl, returning the deleted element

void *poptbl ( Tbl *tbl )
    remove last element from list tbl, returning that element 

void *shifttbl ( Tbl *tbl )
    remove first element from tbl, returning that element 

long pushtbl ( Tbl *tbl, void *value )
    append an element value to the end of the list tbl

long unshifttbl ( Tbl *tbl, void *value )
    insert an element value at the front of the list tbl

int filetbl ( char *name, char *id, long n, void *null, int sz, Tbl **tbl )
    read or create a list in file name with n elements of sz bytes, returning the tbl

Tbl *readtbl ( char *name, char **id, int rw )
    read a list from file name

int savetbl ( Tbl *tbl, char *name, char *id )
    write a list tbl to file name 

Tbl *greptbl ( char *re, Tbl *tbl )
    search each element of list tbl with regular expression re, returning new list of matching rows

Tbl *tblgrep ( Tbl *tbl, char *s )
    considering each element of list tbl as a regular expression, return a new list of elements which match string s

void sorttbl ( Tbl *tbl, int (*cmp)(char *, char *, void *), void *pvt )
    sort a list tbl using the comparison function cmp

long searchtbl ( char *key, Tbl *tbl, int (*cmp)(char*, char*, void*), void *pvt, long *ns, long *ne )
    search a sorted list tbl for key using a binary search and comparison function cmp; return count
    and range ns <= i <= ne of matches

int applytbl ( Tbl *tbl, int (*f)(void*, void*), void *pvt )
    apply function f to each elements of list tbl

Tbl *strtbl ( char *s1, ...)
    create a new list from a variable argument list of strings, terminated with NULL

char *jointbl ( Tbl *tbl, char *s )
    return a new string containing all elements of list tbl, separated by string s.

long cattbl ( Tbl *dst, Tbl *src )
    append list src to list dst

int cmptbl ( Tbl *tbl1, Tbl *tbl2 )
    return 0 if lists tbl1 and tbl2 are identical


int newmorphtbl ( Tbl *list, Morphtbl **map )
    create a new Morphtbl: a list of patterns and substitutions

int morphtbl ( char *old, Morphtbl *map, int flags, char *r )
    apply the patterns and substitutions in map to the string old, leaving
    the result in r. flags may contain MORPH_PARTIAL and/or MORPH_ALL.
    if MORPH_PARTIAL is set, the pattern need not match the entire string.
    if MORPH_ALL is set, all the patterns are applied; otherwise replacement
    stops at the first matching pattern

void freemorphtbl ( Morphtbl *map )
    free Morphtbl map

<subsection Sorted Lists>
<cdeclarations>
Stbl *newstbl (int (*cmp)(void *a, void *b))
    create a new sorted list

void *addstbl (Stbl *stbl, void *key )
    add an element key to sorted list stbl

void *delstbl ( Stbl *stbl, void *key )
    delete element key from sorted list stbl

int freestbl ( Stbl *stbl, void (*sfree)(void *) )
    free sorted list stbl, calling sfree for each element

void *getstbl ( Stbl *stbl, long i )
    return i'th element from sorted list stbl

void *tststbl ( Stbl *stbl, void *key )
    test if element corresponding to key exists in sorted list stbl

long maxstbl ( Stbl *stbl )
    return the number of elements in sorted list stbl

Tbl *tblstbl ( Stbl *stbl )
    return list of all elements in a sorted list (should be freed with freetbl(tbl,0))

int applystbl ( Stbl *stbl, int (*f)(void*, void*), void *pvt )
    call function f for each element of sorted list stbl

<subsection Id Maps>
<cdeclarations>
Stbl * newidmap ( void )
    create a new id map, mapping one set of positive integers to another

void freeidmap ( Stbl *map )
    free idmap map

long idset ( Stbl *map, long key, long x )
    set the value of key in map to x; any previous
    value for key is returned, or -1

long idget ( Stbl *map, long key )
    return the value of key in map, or -1 if it's not set

<subsection Bit Vectors>
<cdeclarations>
Bitvector *bitnew ( )
    create a new bit vector

private Bitvector *bitfile(char *filename, long nbits)
    creates a file representing a bit vector

void bitfree ( Bitvector *b )
    free a bit vector

int bitclr ( Bitvector *b, long index )
    clear bit index of bit vector b

int bitset ( Bitvector *b, long index )
    set bit index of bit vector b

int bittst ( Bitvector *b, long index )
    test bit index of bit vector b

long bitmax ( Bitvector *b )
    return current allocated size of b

Bitvector *bitnot ( Bitvector *b )
    return the bitwise NOT of b

Bitvector *bitand ( Bitvector *b1, Bitvector *b2 )
    return the bitwise AND of b1 and b2

Bitvector *bitor ( Bitvector *b1, Bitvector *b2 )
    return the bitwise OR of b1 and b2

Bitvector *bitxor ( Bitvector *b1, Bitvector *b2 )
    return the bitwise eXclusive-OR of b1 and b2

int bitcmp ( Bitvector *b1, Bitvector *b2 )
    compare two bit vectors

<subsection Simple Ring Buffer>
<cdeclarations>
RingBuffer *openring(char *filename, char *id, int depth, int flags)
    open (or create) a simple ring buffer in filename with size depth

int newring(char *filename, char *id, int depth, int flags)
    create (or reinitialize) a simple ring buffer in filename with size depth

void closering(RingBuffer *rb)
    close the ring buffer rb

int pushring(RingBuffer *rb, double time, double value)
    push a time/value pair onto the ring buffer rb

int getring(RingBuffer *rb, int i, double *time, double *value)
    get the i'th time/value pair from the ring buffer rb 

int countring(RingBuffer *rb)
    return the number of pairs in the ring buffer

double maxring(RingBuffer *rb, double tdelta, int *index)
    return the maximum value and its index within tdelta from the ring buffer rb

double minring(RingBuffer *rb, double tdelta, int *index)
    return the minimum value and its index within tdelta from the ring buffer rb

double avgring(RingBuffer *rb, double tdelta)
    return the average value over tdelta from the ring buffer rb

int findring(RingBuffer *rb, double value, double tdelta)
    find the index of ring buffer entry which has the specified value within tdelta entries

int changedring ( RingBuffer *rb, double tdelta );
    return 1 if the value has changed over the period tdelta

<subsection Time conversion>
<cdeclarations>
int is_epoch_string ( char *s, double *e )
    return true if string s can be interpreted as a time, returning epoch time e

int is_timezone ( char *name )
    returns 1 if file corresponding to name is found, 0 otherwise

private double str2epoch(char *s)
    return epoch time corresponding to string s

private int zstr2epoch(char *s, double *e)
    str2epoch with a return code

double now ()
    return current epoch time, to clock resolution (typically microseconds)

void wait_for_time ( double time, int verbose )
    sleep until specified epoch time

void snooze (double dt)
    sleep (using nanosleep) for specified dt

char *epoch2str ( double e, char *f )
    return freshly allocated string containing epoch time e formatted according to format f

char *zepoch2str ( double epoch, char *f, char *timezone )
    return freshly allocated string containing epoch time e formatted according to format f for timezone; if timezone == 0, use UTC, if timezone == "", use $TZ

private int fmttime ( double e, char *result, int fmt, char *timezone )
    return a formatted time string

char *strdate ( double e )
    return string representing date portion of epoch time

char *strtime ( double e )
    return string representing epoch time

char *strydtime ( double e )
    return standard string representing epoch time

char *strlocaldate ( double e )
    return string representing date portion of local timezone time

char *strlocaltime ( double e )
    return string representing local timezone time

char *strlocalydtime ( double e )
    return string representing local timezone time with yearday

char *strtdelta ( double e )
    return a string representation of elapsed time

double epoch ( int yearday )
    convert yearday to epoch time

long yearday ( double e )
    return yearday corresponding to given epoch time

private void bcdtime ( char *tmstamp, struct date_time *ptim )
    parse BCD timestamp into date-time structure

private void epoch2bcd ( char *tmstamp, double epoch )
    convert epoch time to BCD

private void doy2mday ( int doy, int year, int *month, int *day )
    convert from year and Day-Of-Year doy to month and day of month

private void e2h ( double epoch, int *iyear, int *iday, int *ihour, int *imin, double *sec )
    return year, doy, h:m:s given epoch time

private double h2e ( int iyear, int iday, int ihour, int imin, double sec )
    return the epoch time given inputs

private int mday2doy ( int year, int month, int day )
    convert from year, month, day to Day-Of-Year

private int time_string2epoch ( char *string, double *time )
    earlier interface to str2epoch

<subsection Error handling>
<cdeclarations>
int elog_init ( int argc, char **argv )
    initialize elog routines

private void clear_register ( int deliver )
    clears the error register, printing the contents if asked

private void register_error ( int flag, char *format, ... )

void elog_log ( int flag, char *format, ... )
    save the message specified by sprintf style format and arguments to internal error log; add system error message if flag!=0

void elog_debug ( int flag, char *format, ... )
void elog_notify ( int flag, char *format, ... )
void elog_alert ( int flag, char *format, ... )
void elog_complain ( int flag, char *format, ... )
    deliver the message specified by sprintf style format and arguments, along with any messages on the error log. 
    include system error message if flag!=0

void elog_die ( int flag, char *format, ... )
void elog_fault ( int flag, char *format, ... )
    deliver the message specified by sprintf style format and arguments, along with any messages on the error log. 
    include system error message if flag!=0.
    exit with error code 1

private void complain ( int flag, char *format, ... )

private void die ( int flag, char *format, ... )

char *elog_string ( int first )
    return new string reproducing the entire error log 

char *elogstr ( int severity, int flag, char *fmt, ...)
    return new string corresponding to single elog call, without adding to error log

void elog_clear ()
    clear the log of error messages

int elog_mark ()
    return the number of messages in the error log

void elog_flush ( int deliver, int first )
    flush elog messages from first, printing them if deliver is non-zero

void elog_truncate(int n)
    truncate error log to n messages

void elog_print ( FILE *file, int first )
    print the error log from first to the end

private void elog_free_msg ( void *vmsg )
    free an elog message

private void elog_msg_print ( FILE *file, Elog_msg *elog_msg )
    print an elog message

int elog_query ( enum Elog_code code, int severity, void **value )
    retrieve various parameters from elog interface

int elog_set ( enum Elog_code code, int severity, void *value )
    set various parameters for elog interface

void show_stack_trace ( void )
    print a stack trace from the current execution location

<subsection rtlog routines>
<cdeclarations>
void rtlog_instance (int severity, char *type, char *id, char *fmt, ...)
    record instance event with specified severity, type, id, and (optional) message

void rtlog_scalar (int severity, char *type, char *id, double value, char *fmt, ...)
    record event with specified severity, type, id, 1 scalar value, and (optional) message

<subsection Dynamic Controls>
<cdeclarations>
int dcsetupbyt(char *aname, long value) 
int dcsetupint(char *aname, long value) 
int dcsetupflt(char *aname, double value) 
int dcsetupstr(char *aname, char * value) 
    setup a control of type byte, int, double or string, returning index; value is used to initialize if not already set

int dcgetb(int index) 
double dcgetf(int index) 
long dcgeti(int index) 
char *dcgets(int index) 
    return the value for the specified control byte, int, double or string

int dctrigger(int index)
    return the value for the specified control byte, resetting it to zero

long dcchanged()
    returns integer which is incremented when any control is set

<subsection Filename and Path Manipulation>
<cdeclarations>
int abspath ( char *relp, char *absp )
    return absolute path absp for the relative path relp

int relpath ( char *fromdir, char *tofile, char *relp )
    return a relative path relp from fromdir to tofile

int cleanpath ( char *path, int flags, char *new )
    remove unnecessary '/', '..', and '.' strings from path, returning the result
    in new; if flags is 1, resolve intermediate symbolic links 

char *concatpaths ( char *seg1, *seg2, ...)
    concatenate path segments seg1, seg2, ..., return the result in a new string

int fspath ( char *path, char *host, char *filesystem )
    return host and filesystem corresponding to path

InfoPath *infopath ( char *path )
    return info about path including disk space and inodes available

int freespace ( char *path, double mbavail );
    returns 1 if filesystem where path resides has more than mbavail Mbytes available

int samepath ( char *path1, char *path2 )
    returns 1 if path1 and path2 resolve to same file or directory

char *homedir(char *user)
    return the home directory of the specified user.

unsigned long filesize(char *path)
     return file size for plain file, 0 otherwise

unsigned int filemode(char *path)
     return file mode for file path

unsigned long filetime(char *path)
     return last modification time for path

int is_present(char *path)
     return 1 if path exists, 0 otherwise

int is_empty(char *path)
     for plain file, return 1 if file has size zero
     for directory, return 1 if directory contains no files

int is_file(char *path)
    return 1 if path is plain file, 0 otherwise

int is_filename(char *path)
     return 1 if path begins  with  "/",  "./"  or  "../"; 0 otherwise.

int is_writable_file(char *path)
    return 1 if path is writable or if not present but directory is writable

int is_dir(char *path)
    return 1 if path is directory, 0 otherwise

int is_nfs(char *path)
    return 1 if path is on nfs mounted filesystem, 0 otherwise

int is_changed(char *path)
     return 1 on first call and when mod time changes, or zero if file does not exist

int is_timezeone(char *name)
     return 1 if name is valid time zone

Tbl * dirfiles(char *dir, int flag)
    return list of files in dir; if flag==1, only files, if flag==2, only dirs

int fstraverse(char *dir, int flag, int (*user)(char *, struct stat *, void *), void *pvt)
    run user routine on each file below dir; flag=FS_ONLY_DIR, FS_ONLY_FILE, FS_DEPTH_FIRST

void parsepath ( char *path, char *d, char *b, char *s )
    separate path into directory d and basename b, and suffix s if s!=0

deprecated char **antelope_glob ( char *globpattern )
    shell glob routine

private void dirbase ( char *path, char *dir, char *base )
    separate a path into directory and basename components

private int gethdir ( char *user, char *home )
    get home directory of user

int makedir ( char *dir )
    make complete directory path dir (like "mkdir -p")

int make_pathdirs ( char *path )
    make all directories to path (like "mkdir -p `dirname path`")

long mapfile ( char *name, Arr **arr, char **addr )
    return memory address addr for file name, mmapping it when not present in arr

int unmapfile ( char *name, Arr **arr )
    unmap file name, removing it from arr

int mkfile ( char *name, ulong nbytes, char *init, int initsize)
    make file name nbytes long initialized with the first initsize bytes of init, otherwise zero

<subsection Strings>
<cdeclarations>
int blank ( char *s )
    return non-zero if string is entirely spaces

int whitespace ( char *s )
    return non-zero if string is entirely whitespace

void copystrip ( char *dest, char *source, long n )
    copy a string, stripping leading and trailing blanks

private int cs2fs ( char *dst, char *src, int nmax )
    cast a C string for Fortran

private int fs2cs ( char *dst, char *src, int nmax )
    cast a fortran string to C format

private char *newcs ( char *fs, int n )
    copy a fortran string into a new buffer

void strtrim ( char *s )
    trim leading and trailing whitespace from string s

char *intactline(FILE *file, char **aline, long *size)
    read entire line from file into resizable buffer aline with current size

void chomp ( char *s ) 
    remove trailing linefeed from string s if present

void strtr( char *s, char *from, char *to ) 
    substitute chars in s using lists in from and to  

void str2lower ( char *s )
void str2upper ( char *s )
    convert string s to all lower/upper case

char *okstr( char *s)
    if s != 0, return s otherwise null

void strsub ( char *old, char *s, char *sub, char *r )
    replace all occurences of string s in old with sub, leaving result in r

void regsubstitute ( char *old, char *sub, regmatch_t *matches, char *new ) 
    given results matches of regexec, substitute sub in old, returning result in new

int patsub ( char *old, regex_t *pat, char *sub, char *r )
    replace first occurence of regular expression pat in string old with sub, leaving result in r

int nstrcmp(char *a, char *b)
    return 0 if a==b==0, 1 if only one of a, b is null, otherwise strcmp(a,b)

int strmatches ( char *s, char *pattern, Hook **hook );
    return 1 if entire string s matches the regular expression pattern

int strcontains ( char *s, char *pattern, Hook **hook, long *start, long *nchars );
    return 1 if string s contains the regular expression pattern; the
    index and number of matching chars nchars are returned.

Tbl *split ( char *s, int c )
    return list of fields of s which are delimited by the char c

void sncopy ( char *dst, char *src, long n )
    copy n chars from string src to dst with no trailing null, padding with spaces if necessary

void szcopy ( char *dst, char *src, long n )
    copy n chars from string src to dst, then append null

private int strcpy_pad ( char *dst, int dstmax, char *src, int srcmax, char pad )
    copy a string, truncating or padding as necessary

char *strconcat(char *s, ...)
    return the result of concatenating all the input strings (terminate list with NULL)

char *strjoin(int c, char *s, ... )
    return the result of concatenating all the input strings separated by c (terminate list with NULL)

long pushstrc(void **sbuf, int c )
long pushstrn(void **sbuf, char *s, long n)
long pushstr(void **sbuf, char *s)
    add the string s (or char c) to the string buffer sbuf, creating sbuf if *sbuf == 0, returning new length

char *popstr(void **sbuf, int sfree)
    retrieve the entire string from sbuf, freeing sbuf if sfree != 0

char *strdbl(double x, char *buf)
    formats the input double x into a compact and convenient string

<subsection Sorting and Searching>
<cdeclarations>
void isort ( char *a, long n, int size, int (*cmp)(char*, char*, void*), void *pvt )
    sort list a of n elements each size bytes using the comparison function cmp and
    an insertion sort implementation

void quicksort ( void *a, long n, int size, int (*cmp)(char*, char*, void*), void *pvt )
    sort list a of n elements each size bytes using the comparison function cmp and
    a quick sort implementation

void shellsort ( char *a, long n, int size, int (*cmp)(char*, char*, void*), void *pvt )
    sort list a of n elements each size bytes using the comparison function cmp and
    a shell sort implementation

long ssearch ( char *key, int keysize, char *index, long nkeys, int unique, int (*cmp)(char*, char*, void*), void *pvt, long *ns, long *ne )
    search sorted index for key with binary search, where keys are size bytes and comparison function cmp. 
    return number of matches and the index range ns <= i <= ne of matches.  unique indicates index has no duplicate entries

<subsection User Interaction>
<cdeclarations>
char *ask ( char *format, ... )
    query user for a response

char *asknoecho ( char *format, ... )
    query user for a response with no echo

int askyn ( char *format, ... )
    query user for a yes/no response

int askynaq ( char *format, ... )
    query user for a yes/no/all/quit response

int yesno ( char *s )
    check string for various ways of meaning yes or no

int fdkey ( int fd )
    tests file descriptor for pending input

int fdwait ( int fd, int msec )
    wait up to msec milliseconds for pending input

deprecated int is_tty(int fd)
     return 1 if fd is open to a terminal, 0 otherwise.

int tty_byline(int fd)
int tty_immediate(int fd)
    set line protocol buffering mode

int tty_echo(int fd)
int tty_noecho(int fd)
    set line protocol echo mode

int tty_reset(int fd)
    reset terminal to initial state (before first tty_* call above)

char *getaline ( FILE *file, char *aline, long n )
    reads a line from file, replacing any terminal linefeed
    with a null byte

<subsection Hexadecimal Dumps>
<cdeclarations>
private void Hexdump ( FILE *file, long base, void *mem, int n )
    hex dump a buffer mem, with base added

void hexdump ( FILE *file, void *mem, int n )
    write a hex and ascii dump of n bytes of buffer mem 

char *hexdump_string ( long base, void *mem, int n )
    return string containing hex dump of buffer mem, 
    labelling the address of mem as base.

int read_hexdump ( FILE *file, char *mem, int n )
    read at most n bytes of a hex dump from file into mem

void asciidump ( FILE *file, char *mem, int n )
    write ascii dump of n bytes of buffer mem, with escaped non-printing chars

char *asciistring ( char *memory, int n )
    return string containing ascii dump of nbytes of buffer mem 

int read_asciidump ( FILE *file, char *mem, int n )
    read at most n bytes of a ascii dump from file into mem

void *nomem ( void *mem, int n )
    returns first address in range mem to mem+n that is invalid, 0 otherwise (non-functional in Linux)

int hex2int ( char c )
    return the integer value of a hexadecimal char

int printable ( char *mem, int l )
    return 1 if all l bytes at mem are printable

void printable_string ( char *buf, int p, char *mem, int n )
    copies n bytes from mem to p-byte buf, replacing unprintable chars with hex

long hex2mem ( char *hex, void *vmem );
    convert hexadecimal character string hex into binary in vmem

void mem2hex ( void *vmem, int n, char *s );
    convert n bytes at vmem into hexadecimal character string

<subsection Byteswap Routines>
<body>
Over 250 routines for byteswapping, with names chosen
to indicate source and destination type and architecture,
for example:

#include "swapbytes.h"
</body>
<cdeclarations>
int mf2hd ( void *vfrom, double *to, int n );
int uhs2vb ( short *from, void *vto, int n );
int vt2hi ( void *vfrom, int *to, int n );
int hi2mt ( int *from, void *vto, int n );
</cdeclarations>
<body>

Leading u means unsigned input and output,
next 2 chars indicate source architecture and data type, 
and last 2 chars indicate destination architecture
and data type.
</body>

<example>

Architecture codes 
  h   current host
  a   Intel StrongARM.
  m   Motorola/SPARC 
  v   Vax/Intel


Type codes 
  code   type        bits
  b      byte/char     8
  s      short        16
  t      3-byte       24
  i      int          32
  l      long long    64
  f      float        32
  d      double       64

</example>

<cdeclarations>

char *align_double ( char *a )
    align an address a to a multiple of double

char *align_long ( char *a )
    align an address a to a multiple of long

char *align_int ( char *a )
    align an address a to a multiple of int

<subsection Compression and Checksums>
<cdeclarations>
int gencompress ( uchar **out, int *nout, int *szout, int *in, int n, int len )
    compress n input integers in, using run length len, returning result as
    *nout bytes in *out. 

int genuncompress ( int **out, int *nout, int *size, uchar *in, int n )
    uncompress the n bytes buffer in, returning result as *nout integers in *out.

int ccanada ( int *uc, int nuc, char **cmp, int *ncmp, int *cmpsz )
    compress nuc integers from uc to "Canadian Compression" format,
    result is *ncmp bytes in buffer *cmp of dynamic size *cmpsz.

int ucanada ( char *cmp, int ncmp, int **uc, int *nuc, int *ucsz )
    uncompress "Canadian Compression"  buffer cmp of ncmp bytes, 
    result is *nuc integers in buffer *uc of dynamic size *ucsz.

int cm6 ( int *uc, long nuc, char **cmp, long *ncmp, long *cmpsz )
    compress nuc integers from uc to plain ascii "GSE AutoDRM CM6" format,
    result is *ncmp bytes in buffer *cmp of dynamic size *cmpsz.

long um6 ( char *cmp, long ncmp, int **uc, long *nuc, long *ucsz )
    uncompress plain ascii "GSE AutoDRM CM6" format buffer cmp of ncmp bytes, 
    result is *nuc integers in buffer *uc of dynamic size *ucsz.

int gse_checksum ( int *uc, int nuc )
    compute gse checksum over nuc integers in uc for AutoDRM

int cucsd ( int *uc, int nuc, char **cmp, int *ncmp, int *cmpsz )
    compress nuc integers from uc to UCSD RefTek data logger format,
    result is *ncmp bytes in buffer *cmp of dynamic size *cmpsz.

int uucsd ( int *uc, char **cmp, int ncmp, int nuc )
    uncompress nuc integers from "UCSD RefTek data logger" format buffer cmp of ncmp bytes, 
    advancing *cmp to the next location after uncompressed data

void bt_crc16 ( short *crc, uchar *buf, int size );
    accumulate 16 bit crc over size chars in buf in *crc

void bt_crc32 ( int *crc, uchar *buf, int size );
    accumulate 32 bit crc over size chars in buf in *crc

void bt_crc64 ( long *crc, uchar *buf, int size );
    accumulate 64 bit crc over size chars in buf in *crc

FILE *gz_cat ( char *name)
    return FILE opened for reading on the output of "zcat name"

FILE *gz_open (char *name)
    return FILE opened for reading on the uncompressed version of name

int gz_openfd (char *name)
    return file descriptor opened for reading on the uncompressed version of name

private FILE *zopen ( char *filename, char *permissions )
    fopen a compressed or uncompressed file

<subsection Convenience Macros>
<cdeclarations>
allot(type *, name, n)
    malloc space for n (type *) elements, putting the address in name

reallot(type *, name, n)
    realloc space for n (type *) elements, putting the address in name

<body>
allot and reallot both use ALLOTERROR, which may be defined as
ALLOTDIE (default), ALLOTCOMPLAIN, ALLOTREGISTER_ERROR, or your
own macro
<cdeclarations>

SIZE_BUFFER(type *, buffer, sizevar, needed)
    ensure that (type *) buffer (currently allocated with size in sizevar) has space for at least needed elements -- if not, free the old buffer, and malloc a new buffer

RESIZE_BUFFER(type *, buffer, sizevar, needed)
    ensure that (type *) buffer (currently allocated with size in sizevar) has space for at least needed elements -- if not, realloc the old buffer, copying the current contents

private SQR(a)
    expands to (a)*(a) -- bad if a has side effects

private ABS(a)
    expands to ((a>=0)?(a):-(a)) -- bad if a has side effects

private SIGN(a)
    expands to (((a)>0)? 1.0 : ((a)<0) ? -1.0 : 0.0) -- bad if a has side effects

private MAX(a,b)
    expands to ((a>b)?(a):(b)) -- bad if a or b have side effects

private MIN(a,b)
    expands to ((a>b)?(b):(a)) -- bad if a or b have side effects

<subsection IEEE Arithmetic>
<cdeclarations>
int is_infinity ( double x )
    return 1 if x is infinity

int is_denormalized ( double x )
    return 1 if x is denormalized

int is_nan ( double x )
    return 1 if x is nan

int is_negative_infinity ( double x );
    return 1 if x is -infinity

double an_infinity ( void );
    return an infinity

double a_nan ( void ) ;
    return a (quiet) nan

double a_quiet_nan ( void );
    return a quiet nan

double a_signaling_nan ( void );
    return a signaling nan

<subsection Local Machine/Architecture>
<cdeclarations>
int my_hardware(char *hdw)
    return processor name (sparc, i386, ..)

int my_hostname(char *name)
    return hostname 

int my_ip(char *hostname, char *ipc, int *ip)
    return ip address, as integer and in dot notation

private int my_ips (int *ips) 
    returns up to MAX_IPS ip addresses in ips; count is return code

private int my_ipaddress ()
    returns a single ip address for the current machine

int my_os(char *name)
    return operating system (Solaris, Linux, ...)

int my_username(char *name)
    return the login id 

int ip2name(int addr, char *name)
    return name corresponding to addr

int name2ip(char *name, struct in_addr *addr, char *ipstr)
    return ip address for name

int pid_exists(int pid) ;
     return 1 if process pid exists, 0 otherwise.

char *pidexecname(int pid)
    return path to executable for process pid

char *pidcmdline(int pid)
    return command line for process pid
            
char *pidpwd(int pid)
    return working directory for process pid

int pidinfo(int pid, Pidstat *process)
    return ppid, uid, memory size, resident set size, run state, start time, 
    cpu time for process pid

void syscpu(int *ncpu, CpuUsage **cpu)
    return user, nice, system and idle time for each cpu

int sysncpu ()
    returns number of processors

void sysloadavg(double *avg, int *nproc)
    return 1 minute, 5 minute and 15 minute load averages

void sysmem(double *total, double *physical, double *used)
    return size of virtual and actual physical memory, and size
    of memory in use.

int sysproc(Tbl **procsp)
    return list of system processes, with pid, uid, ppid, pcpu, state, 
    and cpu time for each

int sysmounted(Tbl **sysmnt)
    return list of mounted filesystems, with mount point, filesystem type, 
    and remote host and filesystem if mounted remotely.

private void *std_dlopen (const char *lib)
    dynamically load a dynamic library lib from $ANTELOPE/lib

private int std_getpwnam ( char *user, struct passwd *pwdp )
    thread safe version, fills pwd with zeros when it fails

private int std_set_timer (void (*alarm_handler)(void), double how_long) 
    sets a timer which calls alarm_handler when it expires.

private int std_statvfs(const char *path, Std_statvfs *buf)
    SunOS statvfs/Linux-Darwin statfs substitute

long sysboottime()
     returns estimate of last time the system was booted 


<subsection Environment>
<cdeclarations>
int envfile ( char *filename )
    set environment using list in $ANTELOPE/data/env/filename

int fixup_env ( char **list, int n, int force )
    set environment using list; if force==0, set only unset variables 

private char *getantelope ( )
    return the ANTELOPE root directory

char *expand_env ( char *s )
    return new string substituting $env or ${env} in s with value from environment

<subsection Data File References>
<cdeclarations>
char *datafile ( char *env, char *file)
    return path of filename file in $ANTELOPE/data, perhaps overridden by environment variable env

char *datapath ( char *env, char *dir, char *file, char *sfx )
    return path of filename file (with suffix sfx) in directory dir under $ANTELOPE/data, perhaps overridden by environment variable env

int newdata ( char *path, char *env, char *dir, char *file, char *sfx )
    return complete path for file (with suffix sfx) in directory dir under $ANTELOPE/data, 
    allowing environment variable env to override

Tbl *datasearch(char *search, char *dir, char *file, int flags)
    return paths matching dir/file along the path search. If (flags & 1), expand $name in search; if (flags & 2), return non-existent paths too

deprecated int mappath ( char *spath, char *upath )
    translate pathnames (formerly used for remapping automount paths)

deprecated void setmapcf ( char *fn )
    set the name of the configuration file for mappath

<subsection State Files>
<cdeclarations>
int bury ( )
    save state file, specified by exhume and resurrect calls

int exhume ( char *nm, int *stop, int sec, void (*f)(Pf *) )
    recover state file nm, and set up to save new copy. set up interrupt
    handlers to set flag stop and timer. If timer
    expires sec seconds later, calls bury and exits.

int resurrect ( char *name, Relic value, Relic_type type )
    recover old value for name from state file, set up to save on later
    calls to bury. type is INT_RELIC, DOUBLE_RELIC or STRING_RELIC

char *gravesite ()
    returns filename for state file

<subsection Buffered Network Stream I/O>
<cdeclarations>
Bns *bnsnew ( int fd, long sz )
    create a new network stream I/O buffer

void bnsfree ( Bns *bns )
    free space for bns

int bnsclose ( Bns *bns )
    close file descriptor and free space for bns

void bnsuse_sockio ( Bns *bns )
    setup bns to use socket routines rather than read and write

int bnsget ( Bns *bns, void *data, int t, long n )
    get n elements of type t from bns, returning the result in data ;
    t may be BYTES, TWO_BYTES, INT_FOUR_BYTES, INT_EIGHT_BYTES, FLOAT_FOUR_BYTES, or FLOAT_EIGHT_BYTES

int bnsgetc(Bns *bns, void *data, long mx, int c)
     search for first char c in input, returning up to mx chars including c

long bnsin(Bns *bns)
     return count of chars gotten since previous bnsin call

long bnsout(Bns *bns)
     return count of chars written since previous bnsout call

char *bnsid(Bns *bns, char *id)
     return existing value, sets to new id if id != 0

int bnsput ( Bns *bns, void *data, int t, long n )
    put n elements of type t from data, into buffer of bns 

int bnsflush ( Bns *bns )
    write all data currently in bns buffer

int bnssnoop (Bns *bns, char *filename)

void bnsmark ( Bns *bns )
    save the current read point in the input buffer; keep all
    data after this mark until bnsrelease

void bnsrelease ( Bns *bns )
    reset mark on the input buffer

void bnsrestore ( Bns *bns )
    back up bns pointer to previous mark 

void bnsclr ( Bns *bns )
    wipe clean the bns buffer

long bnscnt ( Bns *bns )
    return count of bytes in bns buffer

int bnseof ( Bns *bns )
    return non-zero when end of file occurs on input

int bnserr ( Bns *bns )
    return non-zero after an error occurs on a bns

int bnserrno ( Bns *bns )
    return any system errno recorded by bns after read or write

long bns2buf ( Bns *bns, char *buf, long maxbuf )
    copy bns buffered data elsewhere

int buf2bns ( Bns *bns, char *buf, long nbytes )
    put data directly into a bns buffer

int bnstimeout ( Bns *bns, int milliseconds )
    set the bns timeout period

int bnswait ( Bns *bns )
    wait until the bns timeout for data to appear

int gbnsSync ( Bns *bns, char *sync, int nsync, int strict )
    read bns input until nsync chars matching sync are encountered

int pbnsSync ( Bns *bns, char *sync, int nsync )
    write nsync chars of sync to bns output

<subsection Miscellaneous>
<cdeclarations>
void banner ( char *program, char *version )
    print header with program name, version; if 0, program & version are taken from elog_init args

void announce ( char *program, char *version )
char *announce_str ( char *program, char *version ) ;
    announce start of execution

deprecated void cbanner ( char *version, char *usage, char *author, char *location, char *email )
    print header with program name, version, usage, and author contact information

void *usermethod ( char *method )
    return pointer to routine method from libuser.so 

int verbose_exists ()
    return 1 if file "verbose" exists, 0 otherwise

Hook *new_hook ( void (*hookfree)(void *) )
    create a standard structure which contains a pointer to a free routine and
    a (void *) pointer

void free_hook ( Hook **hook )
    free a hook structure, first calling the hookfree routine to free the private pointer, and then freeing the structure

int runcmd ( char **argv, char **result )
    execute a command, returning a result and the exit code

void xargs ( char *cmd, Tbl *list, char *tail, int verbose)
    run cmd repeatedly on elements of list until list is exhausted.  tail 
    is appended to each command; verbose causes each to be printed.

double sz2dbl(char *size) 
    takes input like 10k and return 10000 -- knows G, M, k, u and m

deprecated Signal_info *signal_byname ( char *name )
    translate a signal name into description

deprecated Signal_info *signal_bysig ( int sig )
    translate a signal code into name and description

void *memdup(void *a, long n)
    return pointer to copy of n bytes of memory at address a

int xlatname ( char *name, Xlat *xlat, int nxlat )
    return number corresponding to name in translation table xlat

char *xlatnum ( int num, Xlat *xlat, int nxlat )
    return name corresponding to number in translation table xlat

private int clr_fl ( int fd, int flags )
    clear file status flags

private int set_fl ( int fd, int flags )
    set file status flags

void fill_random ( uchar *buffer, int nbytes, int *position )
    fill a buffer with random values

int check_random ( uchar *buffer, int nbytes )
    compare a buffer previously filled with fill_random
    with the values expected.

int set_random ( int nbytes )
    set the size of the check_random internal buffer

double disordered()
    uniform [0,1] pseudo random number

int legit_ip ( char *pfname, unsigned int ip, char **limit )
int legit_ip_pf ( Pf *pf, unsigned int ip, char **limit )
int legit_fd (char *pfname, Pf *pf, int fd, char **limit )  
    compare input ip address to list of valid_ip_addresses (and optional
    list of rejected_ip_addresses) in pf,
    returning 1 if valid, and remainder of matching line in limit

int units_convert(double x, char *x_units, char *want, double *y, char *y_units)
    convert input value x x_units to units want, leaving result y y_units   

Tbl *units_match(char *x_units)
    return a list of all units which match x_units (except x_units)

<subsection Signatures>
<cdeclarations>

int sgsign ( char *signer, char *data, int nbytes, char *signature );
    computes a signature for nbytes of data using method dictated by signer
int sgverify ( char *signer, char *data, int nbytes, char *signature );
    verifies the signature for nbytes of data using method dictated by signer
    
<subsection Reading Files with mmap>
<cdeclarations>
int gxopen(char *filename)
    return fd for filename using mmap

int gxclose(int fd)
    closes fd (unmaps file)
    
int gxline(int fd, char *aline, int maxchars)
    return line from file

int gxseek(int fd, int p)
    seeks to position p in file

int gxtell(int fd)
    return current position in file

int gxpipe(char *cmd, char **env, int *cmdin)
    execute cmd with environment env, cmdin is fd for stdin of cmd  
