#
#   Copyright (c) 2007-2010 Lindquist Consulting, Inc.
#   All rights reserved. 
#                                                                     
#   Written by Dr. Kent Lindquist, Lindquist Consulting, Inc. 
#
#   This software is licensed under the New BSD license:
#
#   Redistribution and use in source and binary forms,
#   with or without modification, are permitted provided
#   that the following conditions are met:
#   
#   * Redistributions of source code must retain the above
#   copyright notice, this list of conditions and the
#   following disclaimer.
#   
#   * Redistributions in binary form must reproduce the
#   above copyright notice, this list of conditions and
#   the following disclaimer in the documentation and/or
#   other materials provided with the distribution.
#   
#   * Neither the name of Lindquist Consulting, Inc. nor
#   the names of its contributors may be used to endorse
#   or promote products derived from this software without
#   specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
#   CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
#   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
#   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
#   THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY
#   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
#   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
#   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
#   IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
#   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
#   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#   POSSIBILITY OF SUCH DAMAGE.

use Carp;
use POSIX ();
use POSIX ":sys_wait_h";
use POSIX qw(setsid setpgid) ;
use Tk;
use Tk::widgets qw(JPEG);
use Tk::NoteBook;
use Tk::LabEntry;
use Tk::BrowseEntry;
use Tk::Balloon;
use Tk::Frame;
use Tk::LabFrame;
use Tk::FileSelect;
use Tk::Table;

use Datascope;
use children;
use ptkform;
use ptkalert;
use staticsys;

$HOME = $ENV{'HOME'};
if( $HOME !~ m@^/@ ) {
	exit( 0 );
}

delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

if( defined( $ENV{'DISPLAY'} ) && $ENV{'DISPLAY'} =~ m@(.*\:.*)@ ) {

	$ENV{'DISPLAY'} = $1;

} else {

	elog_die( "DISPLAY environment variable is defined and does not contain ':'. Failed taint-checking\n" );
}

# Launder @INC to prevent taint-check death within Carp:
for( $i = 0; $i < scalar( @INC ); $i++ ) {
        if( $INC[$i] =~ m@^(/.*)@ ) {
                $INC[$i] = $1;
        } else {
                $INC[$i] = undef;
        }
}

require Tk::ErrorDialog;

# Allow overload redefinitions: 
no warnings 'redefine';

# Overload to work around taint-check problems:
sub Tk::After::cancel
{
 my $obj = shift;
 my $cancelid  = $obj->[1];
 my $w   = $obj->[0];
 if ($cancelid)
  {
   if( defined( $w->{_TkValue_} ) && $w->{_TkValue_} =~ m@^(\..*)@ ) {
      $w->{_TkValue_} = $1;
   }
   $w->Tk::after('cancel'=> $cancelid) if Tk::Exists($w);
   delete $w->{_After_}{$cancelid} if exists $w->{_After_};
   $obj->[1] = undef;
  }
 return $obj;
}

# Overload to work around taint-check problems:
sub rtbkg { 
    my ( $cmd, $stdout, $stderr ) = @_ ; 
    # printf STDERR "rtbkg: '$cmd' > %s 2> %s\n", $stdout // "<stdout>", $stderr // "<stderr>" ;
    my ( $pid ) ;
    if ( $pid = fork ) { 
	# parent
	return  $pid ; 
    } elsif ( defined $pid ) {
	# child
	setsid() ;
	open ( STDIN, "/dev/null" ) ; 
	if (defined $stdout) { 
	    open ( STDOUT, ">$stdout" ) or
	    	warn "Can't open '$stdout' for writing : $!\n" ; 
	    STDOUT->autoflush(1);
	    if (defined $stderr) { 
		open ( STDERR, ">$stderr" ) or
		    warn "Can't open '$stderr' for writing : $!\n" ; 
		STDERR->autoflush(1);
	    } else { 
		open ( STDERR, ">&STDOUT" ) ;
	    }
	}
	# print STDERR "exec'ing '$cmd'\n" ;
        exec $cmd 
	    or print STDERR ( "Can't exec '$cmd' : $!\n" ) ; 
	exit 1 ; 
    } else {
	# fork failure
        print STDERR "Can't fork '$cmd'\n" ; 
	return -1 ; 
    }
}

sub is_tainted {
	return ! eval { eval("#" . substr(join("", @_), 0, 0)); 1 };
}

sub Usage {

	my( $usage ) = "Usage: $Program " .
		       "[{-nowait|-nostarttalk}] [-appname window_name] " .
		       "[-dbxcor_appname window_name] " .
		       "[-winfile filename] [-comout named_pipe] " .
		       "[-geom dbpick_geometry] [-pf pfname] " .
		       "dbname \[trial_dbname\]\n";

	return( $usage );
}

# Overload to work around taint-check problems:
sub ptkalert::position { 
    my($MW, $top) = @_ ; 
    my $x = $MW->rootx - int($top->width/2) ;
    my $dy = 50 ; 
    if ( $MW->height < 50 ) { 
	$dy  = int($MW->height/2) ; 
    }
    my $y = $MW->rooty + $dy ; 
    if( $x =~ /([[:digit:]+-]+)/ ) {
	$x = $1 ;
    }
    if( $y =~ /([[:digit:]+-]+)/ ) {
	$y = $1 ;
    }
    $top->geometry("+$x+$y") ;
}

sub safe_ptkalert {
	my( $w, $msg ) = @_;

	if( defined( $w ) ) {

		ptkalert( $w, $msg );
		
	} else {

		elog_complain( $msg );
	}
}

# Overload to work around taint-check problems:
sub Tk::FileSelect::reread
{
 my ($w) = @_;
 my $dir = $w->cget('-directory');
 if (defined $dir)
  {
   if (!defined $w->cget('-filter') or $w->cget('-filter') eq '')
    {
     $w->configure('-filter', '*');
    }
   my $dl = $w->Subwidget('dir_list');
   $dl->delete(0, 'end');
   $dl->selectionClear(0,'end');
   my $fl = $w->Subwidget('file_list');
   $fl->delete(0, 'end');
   local *DIR;
   if (opendir(DIR, $dir))
    {
     my $file = $w->cget('-initialfile');
     my $seen = 0;
     my $accept = $w->cget('-accept');
     # Insert taint-checking here:
     my @taintentries = readdir(DIR);
     my @cleanentries;
     foreach my $f ( @taintentries ) {
	if( $f =~ m@(.*)@ ) {
		push( @cleanentries, $1 );
	}
     }
     foreach my $f (@cleanentries)
      {
       next if ($f eq '.');
       my $path = "$dir/$f";
       if (-d $path)
        {
         $dl->insert('end', $f);
        }
       else
        {
         if (&{$w->{match}}($f))
          {
           if (!defined($accept) || $accept->Call($path))
            {
             $seen = $fl->index('end') if ($file && $f eq $file);
             $fl->insert('end', $f)
            }
          }
        }
      }
     closedir(DIR);
     if ($seen)
      {
       $fl->selectionSet($seen);
       $fl->see($seen);
      }
     else
      {
       $w->configure(-initialfile => undef) unless $w->cget('-create');
      }
    }
   $w->{DirectoryString} = $dir . ($dir ne '/' ? '/' : '') . $w->cget('-filter');
  }
 $w->{'reread'} = 0;
 $w->Unbusy if $w->{'Busy'};
}

sub MainWindow::Receive {
	my( $objref, $string ) = @_;

	$string =~ s/^\s*//;

	my( @allowed ) = qw( quit_smartpick
			     finish_pspipe
			     \$State{orid}\s+=\s+[[:digit:]-]+ 
			     \@{\$State{stas}}\s+=\s+qw\\\([[:alnum:][:space:]]+\\\) 
			     \$State{dbloc_channels}\s+=\s+[^/]+ 
			     print.* );

	my( $regex ) = join( "|", @allowed );

	if( $string =~ /^($regex)$/ ) {
		
		$string = $1;

	} else {

		elog_complain( "ignoring unwelcome tksend instruction " .
			       "'$string'\n" );

		return;
	}

	eval $string;

	return;
}
 
sub parse_command_line {

	$State{nowait} = 0;
	$State{appname} = "dbpick";
	$State{dbxcor_appname} = "dbxcor";
	$State{winfile} = unique_dbpick_winfile_name();

	while( $item = shift( @_ ) ) {
		
		if( $item eq "-nowait" || $item eq "-nostarttalk" ) {
			
			$State{nowait} = 1;

		} elsif( $item eq "-appname" ) {
			
			$State{appname} = shift( @_ );

		} elsif( $item eq "-dbxcor_appname" ) {
			
			$State{dbxcor_appname} = shift( @_ );

		} elsif( $item eq "-winfile" ) {
			
			$State{winfile} = shift( @_ );

		} elsif( $item eq "-geom" ) {
			
			$State{geom} = shift( @_ );

		} elsif( $item eq "-comout" ) {
			
			$State{comout} = shift( @_ );

		} elsif( $item eq "-pf" ) {
			
			$State{pf} = shift( @_ );

		} else {
			
			unshift( @_, $item );

			last;
		}
	}

	if( @_ < 1 ) {

    		die ( Usage() ); 

	} else {
	
		$State{dbname} = shift( @_ );
	}

	$State{trial_dbname} = shift( @_ );

	# Trust the command line: 

	foreach $arg qw( dbname trial_dbname nowait appname dbxcor_appname 
			 comout winfile geom pf ) {

		if( defined( $State{$arg} ) && $State{$arg} =~ m@(.*)@ ) {
		
			$State{$arg} = $1;
		}
	}	
	
	return;
}

sub finish_pspipe {
	
	if( ! -e $State{pspipe_tempfile} || -z $State{pspipe_tempfile} ) {

		safe_ptkalert( $MW, 
			"Dbpick postscript file '$State{pspipe_tempfile}' " . 
			"is non-existent or empty. Cancelling request." );

		return;
	}

	my( $cmd ) = "cat $State{pspipe_tempfile} | $State{pspipe_command}";

	rtbkg( $cmd );

	unlink( $State{pspipe_tempfile} );

	return;
}

sub print_dbpick {
	
	$State{pspipe_command} = $State{print_command};

	$State{pspipe_tempfile} = "/tmp/smartpick_ps_$>_$$.ps"; 

	my( $dbpick_cmd ) = "ps $State{pspipe_tempfile}";
	    $dbpick_cmd   .= " send smartpick finish_pspipe";

	send_to_dbpick( $dbpick_cmd );

	return;
}

sub pipe_dbpick {
	
	$State{pspipe_command} = ptkask( $MW, 
		"Pipe postscript to command:" );

	$State{pspipe_command} =~ s/^\s*\|//g;

	if( $State{pspipe_command} =~ /^\s*$/ ) {
		
		return;
	}

	$State{pspipe_tempfile} = "/tmp/smartpick_ps_$>_$$.ps"; 

	my( $dbpick_cmd ) = "ps $State{pspipe_tempfile}";
	    $dbpick_cmd   .= " send smartpick finish_pspipe";

	send_to_dbpick( $dbpick_cmd );

	return;
}

sub postscript_dbpick {
	
# FileSelect is having taint problems
#	my( $psfile ) = $MW->FileSelect( 
#			-directory => ".",
#			-initialfile => "$State{default_postscript_file}",
#			-create => 1,
#			-title => "Postscript file" )->Show;
	
	my( $psfile ) = ptkask( $MW, 
		"Enter filename into which to save postscript:" );

	send_to_dbpick( "ps $psfile" );

	return;
}

sub open_arrivals {
	
	my( $dbname ) = $MW->FileSelect( 
			-directory => ".",
			-create => 1,
			-title => "Open Secondary Arrivals Database" )->Show;

	send_to_dbpick( "oa $dbname" );

	return;
}

sub open_events {
	
	my( $dbname ) = $MW->FileSelect( 
			-directory => ".",
			-create => 1,
			-title => "Open Secondary Events Database" )->Show;

	send_to_dbpick( "oe $dbname" );

	return;
}

sub open_detections {
	
	my( $dbname ) = $MW->FileSelect( 
			-directory => ".",
			-create => 1,
			-title => "Open Secondary Detections Database" )->Show;

	send_to_dbpick( "od $dbname" );

	return;
}

sub snapshot_dbpick {
	
# FileSelect is having taint problems
#	my( $snapshotfile ) = $MW->FileSelect( 
#			-directory => ".",
#			-initialfile => "$State{default_snapshot_file}",
#			-create => 1,
#			-title => "Snapshot file" )->Show;

	my( $snapshotfile ) = ptkask( $MW, 
		"Enter filename into which to save snapshot:" );

	my( $winid ) = get_dbpick_win_id();

	my( $cmd ) = "import -silent -window $winid $snapshotfile";

	rtbkg( $cmd );

	return;
}

sub crunch_tables {

	foreach $table ( @{$State{crunch_on_exit}} ) {

		system( "dbcrunch $State{dbname} $table" );
	}
}

sub quit_smartpick {

	kill_dbpick();

	kill_dbxcor();

	crunch_tables();

	if( -e "$State{winfile}" ) {
		
		unlink( $State{winfile} );
	}

	$MW->destroy();
}

sub get_dbpick_win_id  {
 
	if( ! -e "$State{winfile}" ) {

		return -1;
	}

 	my( $winid ) = `cat $State{winfile}`;

	$winid = sprintf( "0x%x", $winid );

	return $winid;
}

sub unique_dbpick_winfile_name {
 
	my( $base ) = "$HOME/.smartpick_dbpick";

	if( $base =~ m@^(/.*)$@ ) {
		
		# Safe to store this anywhere

		$base = $1;

	} else {
	
		elog_die( "Unique dbpick winfile contains unexpected " .
			  "characters. Bye.\n" );

	}

 	if( ! -e "$base" ) {

 		return "$base";

 	} else {

 		my( $i ) = 2;

 		while( -e "$base$i" ) {

 			$i++;
 		}

 		return "$base$i";
 	}
}

sub freeze_size {

	my $geometry = $MW->geometry();

	my( $width, $height );

	if( $geometry =~ /^([[:digit:]]+)x([[:digit:]]+)/ ) {
	
		$width = $1;
		$height = $2;
	}

	$MW->maxsize( $width, $height );

	$MW->resizable( 0, 0 );
}

sub start_dbe {
 
	my( $cmd ) = "dbe $State{dbname}";

	rtbkg( $cmd );

	return;
}

sub start_dbpick {
 
 	$State{DbpickCommandWindowName} = "smartpick_dbpick_$$";

	$State{orid} = -1;
 
 	my( $iconic, $dbpick_command_geometry );

	if( $State{dbpick_command_iconified}) {

		$iconic = "-iconic";

	} else {

		$iconic = "";
	} 

	if( $State{dbpick_command_geometry} && 
	    $State{dbpick_command_geometry} ne "" ) {

		$dbpick_command_geometry = 
			"-geometry $State{dbpick_command_geometry}";

	} else {

		$dbpick_command_geometry = "";
	} 

	if( $State{dbpick_geometry} && 
	    $State{dbpick_geometry} ne "" ) {

		$dbpick_geometry = 
			"-geom $State{dbpick_geometry}";

	} else {

		$dbpick_geometry = "";
	} 

	my( $appname );

	if( $State{appname} && 
	    $State{appname} ne "" ) {

		$appname = "-appname $State{appname}";

	} else {

		$appname = "";
	} 

	if( $State{winfile} && 
	    $State{winfile} ne "" ) {

		$winfile = "-winfile $State{winfile}";

	} else {

		$winfile = "";
	} 

	if( $State{comout} && 
	    $State{comout} ne "" ) {

		$comout = "-comout $State{comout}";

	} else {

		$comout = "";
	} 

	my( $cmd ) = "xterm " .
		     " -title $State{DbpickCommandWindowName} $iconic " .
		     "$dbpick_command_geometry " .
		     "-e dbpick -nostarttalk $winfile $dbpick_geometry " .
		     "$appname $comout $State{dbpick_options} " .
		     "$State{dbname}";

	$State{DbpickPid} = rtbkg( $cmd );

 	# Let the window get created!: 
 	sleep( 1 );

	$res = 
	 `xwininfo -int -name $State{DbpickCommandWindowName} | grep xwininfo`;

 	$State{DbpickCommandWindow} =  (split( /\s/, $res ))[3];

	if( defined( $State{overlay_time_correction} ) &&
	    $State{overlay_time_correction} ne "" &&
	    $State{overlay_time_correction} != 0.0 ) {

	    $State{tc} = $State{overlay_time_correction};

	    set_dbpick_tc();
	}

	return;
}

sub start_dbxcor {

	my( $dbxcor_appname );

	if( $State{dbxcor_appname} && 
	    $State{dbxcor_appname} ne "" ) {

		$dbxcor_appname = "-appname $State{dbxcor_appname}";

	} else {

		$dbxcor_appname = "-appname dbxcor";
	} 

	my( $cmd ) = "xterm " .
		     "-title dbxcor_output " .
		     "-e /bin/sh -c 'dbxcor $State{dbname} -v $dbxcor_appname 2>&1 | tee $State{dbxcor_log_file}'";

	$State{DbxcorPid} = rtbkg( $cmd );

	return;
}

sub send_to_dbpick {
	my( $command, $silent ) = @_;

	chomp( my( @tkapps ) = `unregister` );

	map { $_ =~ s/^[[:alnum:]]+ // } @tkapps;

	if( grep( /^$State{appname}$/, @tkapps ) ) {

		$MW->send( "-async", $State{appname} => "$command" );

	} elsif( ! $silent ) {
		
		safe_ptkalert( $MW, "Couldn't find an application with the TCL/Tk" .
			"name '$State{appname}'. Is dbpick running?" );
	}
}

sub send_to_dbxcor {
	my( $command, $silent ) = @_;

	chomp( my( @tkapps ) = `unregister` );

	map { $_ =~ s/^[[:alnum:]]+ // } @tkapps;

	if( grep( /^$State{dbxcor_appname}$/, @tkapps ) ) {

		$MW->send( "-async", $State{dbxcor_appname} => "$command" );

	} elsif( ! $silent ) {
		
		safe_ptkalert( $MW, "Couldn't find an application with the TCL/Tk" .
			"name '$State{dbxcor_appname}'. Is dbxcor running?" );
	}
}

sub send_to_dbloc {
	my( $command, $silent ) = @_;

	chomp( my( @tkapps ) = `unregister` );

	map { $_ =~ s/^[[:alnum:]]+ // } @tkapps;

	if( grep( /^dbloc_buttons$/, @tkapps ) ) {

		$MW->send( "-async", "dbloc_buttons" => "$command" );

		return 0;

	} elsif( ! $silent ) {
		
		safe_ptkalert( $MW, "Couldn't find an application with the TCL/Tk" .
				"name 'dbloc_buttons'. Is dbloc2 running?" );

		return -1;
	}
}

sub ask_dbloc2 { 
	my( $q ) = @_;

	if( $q eq "channels" ) {

		my( $cmd ) = "send -async smartpick " . 
			"\\\$State{dbloc_channels} = \\\"[channels]\\\"";

		if( send_to_dbloc( $cmd, 0 ) < 0 ) {

			return;

		} else {

			$MW->waitVariable( \$State{dbloc_channels} );
		}
	}
}
 
sub ask_dbpick { 
	my( $q ) = @_;

	if( $q eq "orid" ) {

		send_to_dbpick( "send smartpick \$State{orid} = %orid" );

		$MW->waitVariable( \$State{orid} );

	} elsif( $q eq "stas" ) {

		send_to_dbpick( 
			"send smartpick \@{\$State{stas}} = qw(%stas)" );

		$MW->waitVariable( \@{$State{stas}} );
	}
}
 
sub kill_dbpick {

	send_to_dbpick( "quit", 1 );
}

sub kill_dbxcor {

	send_to_dbxcor( "quit", 1 );
}

sub exec_spgram {

	send_to_dbpick( "exec dbspgram %db %sta %chan %ts %tw &" );
}

sub show_predicted {

	send_to_dbpick( "sp $State{var}->{show_predicted}" );
}

sub np {

	send_to_dbpick( "sp $State{var}->{np}" );
}

sub pp {

	send_to_dbpick( "sp $State{var}->{pp}" );
}

sub default_phase {

	send_to_dbpick( "ph $State{var}->{default_phase}" );
}

sub process_dbxcor_phase {
	my( $phase ) = @_;

	ask_dbpick( "orid" );

	if( $State{orid} < 0 ) {
		
		safe_ptkalert( $MW, "NULL orid in dbpick" );

		return ();
	}

	send_to_dbxcor( "$State{orid} $phase" ); 
}

sub dbxcor {

	process_dbxcor_phase( $State{var}->{dbxcor} );
}

sub gp {

	send_to_dbpick( "gp $State{var}->{gp}" );
}

sub post_wfchange {
	
	if( $State{auto_dw} ) {
		
		send_to_dbpick( "dw" );
	}

	if( $State{auto_sw_on} ) {

		send_to_dbpick( "sw on" );
	}
}

sub get_channels_expr {

	if( ! defined( $State{channels} ) ) {
		
		safe_ptkalert( $MW, "No channels option-menu defined. " .
			"Defaulting to .* for channels" );

		return ".*";
	}

	if( $State{var}->{channels} eq "dbloc2" ) {
		
		ask_dbloc2( "channels" );

		if( $State{dbloc_channels} =~ /sc.*:(\S+)\s*/ ) {
	
			return $1;

		} else {

			return ".*";
		}
	}

	my( $expr ) = $State{channels}->{$State{var}->{channels}};

	if( ! defined( $expr ) ) {
		
		safe_ptkalert( $MW, "No channel-expression " .
				"'$State{var}->{channels} found in " .
			        " parameter file. Defaulting to .*" );

		$expr = ".*";
	}	

	return $expr;
}

sub channels {

	my( $expr ) = get_channels_expr();
	
	ask_dbpick( "stas" );

	my( $sta_expr ) = join( ",", map { $_ .= ":$expr"} @{$State{stas}} );

	send_to_dbpick( "sc $sta_expr" );

	post_wfchange();
}

sub groups { 
	
	show_group( $State{var}->{groups} );
}

sub cts {
	
	if( $State{var}->{cts} eq "Counts" ) {

		send_to_dbpick( "cts on" );

	} elsif( $State{var}->{cts} eq "Physical" ) {

		send_to_dbpick( "cts off" );

	} else {

		safe_ptkalert( $MW, "Unrecognized Units '$State{var}->{cts}' in" .
			"parameter file (must be 'Counts' or 'Physical'); " .
			"Ignoring request" );
	}
}

sub mg {
	
	if( $State{var}->{mg} eq "milli_g" ) {

		send_to_dbpick( "mg on" );

	} elsif( $State{var}->{mg} eq "nm_per_sec_2" ) {

		send_to_dbpick( "mg off" );

	} else {

		safe_ptkalert( $MW, "Unrecognized Acceleration units " .
			"'$State{var}->{mg}' in parameter file " . 
			"(must be 'milli_g' or 'nm_per_sec_2'); " .
			"Ignoring request" );
	}
}

sub pal {
	
	if( $State{var}->{pal} eq "on" ) {

		send_to_dbpick( "pal on" );

	} elsif( $State{var}->{pal} eq "off" ) {

		send_to_dbpick( "pal off" );

	} else {

		safe_ptkalert( $MW, "Unrecognized Waveforms mode " .
			"'$State{var}->{pal}' in parameter file " . 
			"(must be 'on' or 'off'); " .
			"Ignoring request" );
	}
}

sub sw {
	
	if( $State{var}->{sw} eq "Show" ) {

		send_to_dbpick( "sw on" );

	} elsif( $State{var}->{sw} eq "Hide" ) {

		send_to_dbpick( "sw off" );

	} else {

		safe_ptkalert( $MW, "Unrecognized Waveforms mode " .
			"'$State{var}->{sw}' in parameter file " . 
			"(must be 'Show' or 'Hide'); " .
			"Ignoring request" );
	}
}

sub init_database {

	$State{network_stations} = { };
	$State{nettype_networks} = { };
	$State{stations_frame_stations} = [];

	@db = dbopen( $State{dbname}, "r" );

	@db = dblookup( @db, 0, "site", 0, 0 );

	@db = dbsort( @db, "sta" );
	@db = dbsubset( @db, "$State{stations_frame_subset}" );

	$nrecs = dbquery( @db, dbRECORD_COUNT );

	if( $nrecs > 0 ) {

		for( $db[3] = 0; $db[3] < $nrecs; $db[3]++ ) {

			my( $sta ) = dbgetv( @db, "sta" );

			push( @{$State{stations_frame_stations}}, $sta );
		}
	}

	@db = dblookup( @db, 0, "affiliation", 0, 0 );

	$nrecs = dbquery( @db, dbRECORD_COUNT );

	if( $nrecs > 0 ) {

		@db = dbsort( @db, "net", "sta" );

		@db = dbgroup( @db, "net" );

		$ngroups = dbquery( @db, dbRECORD_COUNT );

		for( $db[3] = 0; $db[3] < $ngroups; $db[3]++ ) {
		
			@dbg = split( /\s+/, dbgetv( @db, "bundle" ) );

			my( $first, $last ) = dbget_range( @dbg );

			$dbg[3] = $first;

			$net = dbgetv( @dbg, "net" );

			$State{network_stations}->{$net} = [];

			for( $dbg[3] = $first; $dbg[3] < $last; $dbg[3]++ ) {
	
				$sta = dbgetv( @dbg, "sta" );

				if( $sta =~ /^([[:alnum:]]+)$/ ) {
		
					$sta = $1;
	
				} else {
		
					safe_ptkalert( $MW, "Station name '$sta' " .
					"contains unexpected characters; " .
					"omitting.\n" );
				}
	
				push( @{$State{network_stations}->{$net}}, 
				      $sta );
			}
		}
	}

	@db = dbprocess( @db, "dbopen network",
			      "dbjoin affiliation",
			      "dbseparate network" );

	$nrecs = dbquery( @db, dbRECORD_COUNT );

	if( $nrecs > 0 ) {

		@db = dbsort( @db, "nettype", "net" );

		@db = dbgroup( @db, "nettype" );

		$ngroups = dbquery( @db, dbRECORD_COUNT );

		for( $db[3] = 0; $db[3] < $ngroups; $db[3]++ ) {
		
			@dbg = split( /\s+/, dbgetv( @db, "bundle" ) );

			my( $first, $last ) = dbget_range( @dbg );

			$dbg[3] = $first;

			$nettype = dbgetv( @dbg, "nettype" );

			next if( $nettype eq "-" );

			$State{nettype_networks}->{$nettype} = [];

			for( $dbg[3] = $first; $dbg[3] < $last; $dbg[3]++ ) {
	
				$net = dbgetv( @dbg, "net" );

				if( $net =~ /^([[:alnum:]]+)$/ ) {
	
					$net = $1;

				} else {
	
					safe_ptkalert( $MW, "Network name '$net' " .
					"contains unexpected characters; " .
					"omitting.\n" );
				}

				push( @{$State{nettype_networks}->{$nettype}}, 
				      $net );
			}
		}
	}

	return;
}

sub extract_nearby_stations {
	my( $sta, $n ) = @_;

	my( @stas ) = ();

	@db = dbopen( $State{dbname}, "r" );

	@db = dblookup( @db, "", "site", "sta", "$sta" );

	my( $lat, $lon ) = dbgetv( @db, "lat", "lon" );

	@db = dblookup( @db, "", "site", "", "" );

	@db = dbsort( @db, "distance( $lat,$lon,lat,lon )" );

	my( $nrecs ) = dbquery( @db, dbRECORD_COUNT );

	for( $db[3] = 0; ($db[3] < $nrecs) && ($db[3] <= $n); $db[3]++ ) {

		push( @stas, dbgetv( @db, "sta" ) );	
	}

	return @stas;
}

sub extract_subset {
	my( $subset_expr ) = @_;

	my( @stas );

	@stas = ();

	ask_dbpick( "orid" );

	if( $State{orid} < 0 ) {
		
		safe_ptkalert( $MW, "NULL orid in dbpick" );

		return ();
	}

	@db = dbopen( $State{dbname}, "r" );

	@db = dbprocess( @db, 
			"dbopen origin",
			"dbsubset orid == $State{orid}",
			"dbjoin site",
			"dbsubset $subset_expr",
			"dbsort distance(lat,lon,site.lat,site.lon)" 
			);

	my( $nstas ) = dbquery( @db, dbRECORD_COUNT );

	if( $nstas <= 0 ) {

		safe_ptkalert( $MW, "No stations matching subset expression" );

		return ();
	}

	for( $db[3] = 0; $db[3] < $nstas; $db[3]++ ) {

		my( $sta ) = dbgetv( @db, "sta" );

		push( @stas, $sta );
	}

	return @stas;
}

sub extract_net {
	my( $net ) = @_;

	my( @stas );

	if( ( ! defined( $State{network_stations}->{$net} ) ) || 
	    ( scalar( @{$State{network_stations}->{$net}} ) < 1 ) ) {

		safe_ptkalert( $MW, "No stations for network '$net' in " .
			"affiliation table of $State{dbname}" );

		@stas = ();
		
	} else {

		@stas = @{$State{network_stations}->{$net}};
	}

	return @stas;
}

sub show_group {
	my( $group ) = @_;

	my( $regex );

	my( $expr ) = get_channels_expr();

	if( ! defined( $State{groups}->{$group} ) ) {
	
		safe_ptkalert( $MW, "Can't find group '$group' in parameter-file. " .
			"Ignoring request.\n" );

		return;

	} elsif( $State{groups}->{$group} =~ /^net\((.*)\)/ ) {
	
		my( $net ) = $1;

		my( @stas ) = extract_net( $net );

		if( scalar( @stas ) <= 0 ) {

			safe_ptkalert( $MW, "No stations found for network " .
				"'$net'. Ignoring request.\n" );

			return; 
		}

		$regex = join( ",", map { $_ .= ":$expr"} @stas );

	} elsif( $State{groups}->{$group} =~ /^subset\((.*)\)/ ) {
	
		my( $subset_expr ) = $1;

		my( @stas ) = extract_subset( $subset_expr );

		if( scalar( @stas ) <= 0 ) {

			safe_ptkalert( $MW, "No stations found for subset " .
				"'$subset_expr'. Ignoring request.\n" );

			return; 
		}

		$regex = join( ",", map { $_ .= ":$expr"} @stas );

	} else {

		$regex = $State{groups}->{$group};

		$regex =~ s/,/:$expr,/g;

		$regex .= ":" . $expr;
	}

	send_to_dbpick( "sc $regex" );

	post_wfchange();
}

sub set_dbpick_tc {

	if( $State{tc} =~ /^([[:digit:].\+-]+)$/ ) {
		
		$State{tc} = $1;

	} else {

		safe_ptkalert( $MW, "Invalid time-correction '$State{tc}'" );
	}
	
	send_to_dbpick( "tc $State{tc}" );
}

sub set_dbpick_cm {

	if( $State{cm} =~ /^([[:digit:]]+)$/ ) {
		
		$State{cm} = $1;

	} else {

		safe_ptkalert( $MW, "Invalid max-traces value '$State{cm}'" );
	}
	
	send_to_dbpick( "cm $State{cm}" );
}

sub set_dbpick_cw {

	if( $State{cw} =~ /^([[:digit:]]+\s+[[:digit:]]+)$/ ) {
		
		$State{cw} = $1;

	} else {

		safe_ptkalert( $MW, 
			"Invalid choose-waveforms values '$State{cw}': " .
			"Must be two integer values separated by a space " .
			"(starting trace number, then number of traces)" );
	}
	
	send_to_dbpick( "cw $State{cw}" );
}

sub set_dbpick_orid {

	if( $State{orid} =~ /^([[:digit:]-]+)$/ ) {
		
		$State{orid} = $1;

	} else {

		safe_ptkalert( $MW, "Invalid orid '$State{orid}'" );
	}
	
	send_to_dbpick( "se $State{orid}" );
}

sub set_dbpick_ts {
	
	my( $epoch_time );

	if( $State{ts} =~ /^([^\(\)]+)$/ ) {
		
		$State{ts} = $1;

	} else {
	
		safe_ptkalert( $MW, "Time string '$State{ts} contains invalid " .
			"characters" );

		return;
	}
	
	eval( $epoch_time = str2epoch( $State{ts} ) );

	if( $epoch_time =~ /^([[:digit:].]+)$/ ) {
	
		$epoch_time = $1;
	}

	if( $@ ) {
		
		safe_ptkalert( $MW, "Time string '$State{ts}' not understood" );

		return;
	}

	send_to_dbpick( "ts $epoch_time" );
}

sub set_dbpick_tw {
	
	if( $State{tw} =~ /^([[:digit:].]+)$/ ) {
		
		$State{tw} = $1;

	} else {
	
		safe_ptkalert( $MW, "Time string interval State{tw} contains " .
			"invalid characters" );

		return;
	}
	
	send_to_dbpick( "tw $State{tw}" );
}

sub check_for_executable {
        my( $program ) = @_;

        my( $ok ) = 0;

        foreach $path ( split( ':', $ENV{'PATH'} ) ) {
                if( -x "$path/$program" ) {
                        $ok = 1;
                        last;
                }
        }

        return $ok;
}

sub init_menubar {
	my( $w ) = @_;

	my $w_menubar = $w->Frame()
				->pack( -side => "top", 
				-fill => "x", 
				-expand => "yes" );

	my $w_menubar_File = $w_menubar->Menubutton( 

				-text => "File", 
			        -underline => 0,
			    	-highlightthickness => 0 

			)->pack( -side => "left" );

	my $w_menubar_File_m = $w_menubar_File->Menu( -tearoff => 0 );

	my( $snapshot_state ) = 
		$State{snapshots_possible} ? "normal" : "disabled";

	$w_menubar_File_m->add( "command", -label => "Print", 
				    -underline => 0, 
				    -command => \&print_dbpick );

	$w_menubar_File_m->add( "command", -label => "Snapshot...", 
				    -underline => 0, 
				    -state => $snapshot_state,
				    -command => \&snapshot_dbpick );

	$w_menubar_File_m->add( "command", -label => "Postscript...", 
				    -underline => 1, 
				    -command => \&postscript_dbpick );

	$w_menubar_File_m->add( "command", -label => "Pipe postscript...", 
				    -underline => 1, 
				    -command => \&pipe_dbpick );

	$w_menubar_File_m->add( "command", -label => "Open Arrivals Db...", 
				    -underline => 5, 
				    -command => \&open_arrivals );

	$w_menubar_File_m->add( "command", -label => "Open Events Db...", 
				    -underline => 5, 
				    -command => \&open_events );

	$w_menubar_File_m->add( "command", -label => "Open Detections Db...", 
				    -underline => 5, 
				    -command => \&open_detections );

	$w_menubar_File_m->add( "command", -label => "Quit", 
				    -underline => 0, 
				    -command => \&quit_smartpick );

	$w_menubar_File->configure( -menu => $w_menubar_File_m );

	my $w_menubar_Options = $w_menubar->Menubutton( 

				-text => "Options", 
			        -underline => 0,
			    	-highlightthickness => 0 

			)->pack( -side => "left" );

	my $w_menubar_Options_m = $w_menubar_Options->Menu( -tearoff => 0 );

	$w_menubar_Options_m->add( "checkbutton", -label => "Balloon Help", 
				    -variable => \$State{balloon_help},
				    -onvalue => -1,
				    -underline => 0, 
				    -command => \&toggle_balloons );

	$w_menubar_Options_m->add( "checkbutton", 
				    -label => "Delete Empty Waveforms Automatically", 
				    -variable => \$State{auto_dw},
				    -onvalue => -1,
				    -underline => 0 );

	$w_menubar_Options_m->add( "checkbutton", 
				    -label => "Show Waveforms Automatically", 
				    -variable => \$State{auto_sw_on},
				    -onvalue => -1,
				    -underline => 0 );

	$w_menubar_Options->configure( -menu => $w_menubar_Options_m );

	return;
}

sub shift_ptkform {
	my( $ref ) = @_;

	my( @ptkform_specs ) = ();

	while( @{$ref} ) {

		if( ${$ref}[0] eq "notebook" ||
		    ${$ref}[0] =~ /^toplevel/ ) {

			last;
		
		} else {

			push( @ptkform_specs, shift( @{$ref} ) );
		}
	}

	return @ptkform_specs;
}


sub shift_notebook {
	my( $ref ) = @_;

	my( @notebook_specs ) = ();

	if( ${$ref}[0] ne "notebook" ) {
		
		return;

	} else {

		shift( @{$ref} );
	}

	while( @{$ref} && ( ( $spec = shift( @{$ref} ) ) ne "endnotebook" ) ) {

		push( @notebook_specs, $spec );
	}

	if( $spec eq "endnotebook" ) {

		return @notebook_specs;

	} else {
		
		die( "Error in parameter file: 'notebook' line in 'layout'" .
		 " table does not have matching 'endnotebook' line\n" );
	}
}

sub shift_toplevel {
	my( $ref ) = @_;

	my( @toplevel_specs ) = ();

	my( $geometry ) = "";

	if( ${$ref}[0] !~ /^toplevel\s*([[:alnum:]\+-]+)?/ ) {
		
		return;

	} else {

		if( defined( $1 ) ) {

			$geometry = $1;
		}

		shift( @{$ref} );
	}

	while( @{$ref} && ( ( $spec = shift( @{$ref} ) ) ne "endtoplevel" ) ) {

		push( @toplevel_specs, $spec );
	}

	if( $spec eq "endtoplevel" ) {

		return ( $geometry, @toplevel_specs );

	} else {
		
		die( "Error in parameter file: 'toplevel' line in 'layout'" .
		 " table does not have matching 'endtoplevel' line\n" );
	}
}

sub init_ptkform {
	my( $w, $ref ) = @_;

	my( @specs ) = shift_ptkform( $ref );

	my $ptk_frame = $w->Frame()
				->pack( -side => "top", 
					-fill => "both", 
					-expand => "yes" );

	eval { ptkform( $ptk_frame, 
			$State{var}, 
			$State{widgets}, 
			@specs ) };

	foreach $c ( $ptk_frame->children() ) {

		if( $c->class() eq "Balloon" ) {

			push( @{$State{balloons}}, $c );
		}
	} 

	if( $@ ) {

		elog_die( "Failed to build ptkform-based GUI " .
			  "window: $@. Bye.\n" );
	}

	return;
}

sub init_toplevel {
	my( $w, $ref ) = @_;

	my( $geometry, @specs ) = shift_toplevel( $ref );

	my( $wt ) = $w->Toplevel();

	$wt->title( "smartpick" );

	if( defined( $geometry ) && $geometry ne "" ) {

		$wt->geometry( $geometry );
	}

	my $ptk_frame = $wt->Frame()
				->pack( -side => "top", 
					-fill => "both", 
					-expand => "yes" );

	eval { ptkform( $ptk_frame, 
			$State{var}, 
			$State{widgets}, 
			@specs ) };

	foreach $c ( $ptk_frame->children() ) {

		if( $c->class() eq "Balloon" ) {

			push( @{$State{balloons}}, $c );
		}
	} 

	if( $@ ) {

		elog_die( "Failed to build ptkform-based GUI " .
			  "window: $@. Bye.\n" );
	}

	toplevel_bindings( $wt );

	return;
}

sub init_notebook {
	my( $w, $ref ) = @_;

	my( @specs ) = shift_notebook( $ref );

	my( @pagespecs, $pagename, $ptk_frame );

	my( $notebook ) = $w->NoteBook();

	$notebook->pack( -side => "top", 
			 -fill => "both", 
			 -expand => "yes" );

	while( $spec = shift( @specs ) ) {
		
		if( $spec =~ /^notebook_page\s+([[:alnum:]_]+)/) {
		
			$pagename = $1;

			@pagespecs = ();

			$ptk_frame = $notebook->add( "$pagename", 
					-label => "$pagename", 
					-anchor => "ne" );

		} elsif( $spec =~ /^endnotebook_page/ ) {

			ptksticky( "nsew" ); 

			eval { ptkform( $ptk_frame, 
					$State{var}, 
					$State{widgets}, 
					@pagespecs ) };

			foreach $c ( $ptk_frame->children() ) {

				if( $c->class() eq "Balloon" ) {

					push( @{$State{balloons}}, $c );
				}
			} 

			if( $@ ) {

				elog_die( "Failed to build ptkform-" .
				  "based GUI notebook window: $@. " .
				  "Bye.\n" );
			}

		} else {
			
			push( @pagespecs, $spec );
		}
	}

	return;
}

sub init_layout {
	my( $w ) = shift( @_ );
	my( @specs ) = @_;

	while( @specs ) {

		if( $specs[0] eq "notebook" ) {

			init_notebook( $w, \@specs );

		} elsif( $specs[0] =~ /^toplevel/ ) {

			init_toplevel( $w, \@specs );

		} else {

			init_ptkform( $w, \@specs );
		}
	}

	return;
}

sub init_windows {
	my( @specs ) = @_;
	
	my( $ptk_frame );

	my( $w ) = MainWindow->new();

	unless( $State{unmap_menubar} ) {

		init_menubar( $w );
	}

	# These initializations are critical for ptkform() to initialize
	# the hash references as intended: 

	$State{var} = { };
	$State{widgets} = { };

	$State{balloons} = [ ];

	ptksticky( "nsew" );

	ptkfontsize( $State{smartpick_fontsize} );

	init_layout( $w, @specs );

	if( defined( $State{widgets}->{stations_frame} ) ) {

		init_stations_frame( $State{widgets}->{stations_frame} );
	}

	toggle_balloons(); 

	return ( $w );
}

sub show_station {
	my( $sta ) = @_;

	my( $expr ) = get_channels_expr();
	
	my( @stas ) = ();

	if( $State{num_nearby_stations} > 0 ) {

		my( @nearby ) = extract_nearby_stations( 
				$sta, $State{num_nearby_stations} );

		push( @stas, @nearby );

	} else {

		push( @stas, $sta );
	}

	my( $sta_expr ) = join( ",", map { $_ .= ":$expr"} @stas );

	send_to_dbpick( "sc $sta_expr" );

	post_wfchange();

	return;
}

sub init_stations_frame {
	my( $w ) = @_;	

	my( $table ) = $w->Table( 
			-columns => $State{stations_frame_columns}, 
			-scrollbars => "e" )->pack( -fill => "both", 
						    -expand => "yes" );

	my( $row ) = 0; 
	my( $column ) = 0;

	foreach $sta ( @{$State{stations_frame_stations}} ) {

		my( $swidget ) = $table->Button( 
			-command => [\&show_station, $sta],
			-text => $sta );

		$table->put( $row, $column, $swidget );

		$column++;

		if( $column >= $State{stations_frame_columns} ) {
			
			$row++;
			$column = 0;
		}
	}

	return;
}

sub toggle_balloons {

	if( $State{balloon_help} ) {

		foreach $c ( @{$State{balloons}} ) {

			$c->configure( -state => "both" );
		} 

	} else {

		foreach $c ( @{$State{balloons}} ) {

			$c->configure( -state => "none" );
		} 
	}

	return;
}

sub init_special {
	my( $oridcomb ) = @_;

	if( defined( $State{"current_index_$oridcomb"} ) ) {

		return 0;
	}

	my( @dbprocess_commands ) = @{pfget( $State{pf}, "dbprocess_special{$oridcomb}" )};

	map {

		if( $_ =~ m@^([^\[\]]*)$@ ) {
		
			$_ = $1;

		} else {
		
			elog_die( "dbprocess_special{$oridcomb} table entry '$_' contains disallowed " .
			  	"square-bracket characters. Bye.\n" );
		}

	} @dbprocess_commands;

	if( ! @dbprocess_commands ) {
		
		elog_die( "Can't find table 'dbprocess_special{$oridcomb}' in '$State{pf}.pf'. Bye." );
	}

	@db = dbopen( $State{dbname}, "r" );

	@db = dbprocess( @db, @dbprocess_commands );

	my( $nrecs ) = dbquery( @db, dbRECORD_COUNT );

	if( $nrecs <= 0 ) {

		safe_ptkalert( $MW, "No rows for view specified by 'dbprocess_special{$oridcomb}'" );

		return -1;
	}

	for( $db[3] = 0; $db[3] < $nrecs; $db[3]++ ) {
		
		my( $orid ) = dbgetv( @db, "orid" );

		push( @{$State{"oridcomb_$oridcomb"}}, $orid );
	}

	$State{"current_index_$oridcomb"} = -1;

	return 0;
}

sub first_special {
	my( $oridcomb ) = @_;

	if( init_special( $oridcomb ) < 0 ) {
		
		return;
	}

	$State{"current_index_$oridcomb"} = 0;

	$State{orid} = ${$State{"oridcomb_$oridcomb"}}[$State{"current_index_$oridcomb"}];

	set_dbpick_orid();

	return;
}

sub next_special {
	my( $oridcomb ) = @_;

	if( init_special( $oridcomb ) < 0 ) {
		
		return;
	}

	if( $State{"current_index_$oridcomb"} < $#{$State{"oridcomb_$oridcomb"}} ) {

		$State{"current_index_$oridcomb"}++;

	} else {

		safe_ptkalert( $MW, "Already at last origin for special sequence '$oridcomb'" );

		$State{"current_index_$oridcomb"} = $#{$State{"oridcomb_$oridcomb"}};
	}

	$State{orid} = ${$State{"oridcomb_$oridcomb"}}[$State{"current_index_$oridcomb"}];

	set_dbpick_orid();

	return;
}

sub previous_special {
	my( $oridcomb ) = @_;

	if( init_special( $oridcomb ) < 0 ) {
		
		return;
	}

	if( $State{"current_index_$oridcomb"} > 0 ) {

		$State{"current_index_$oridcomb"}--;

	} else {

		safe_ptkalert( $MW, "Already at first origin for special sequence '$oridcomb'" );

		$State{"current_index_$oridcomb"} = 0;
	}

	$State{orid} = ${$State{"oridcomb_$oridcomb"}}[$State{"current_index_$oridcomb"}];

	set_dbpick_orid();

	return;
}

sub last_special {
	my( $oridcomb ) = @_;

	if( init_special( $oridcomb ) < 0 ) {
		
		return;
	}

	$State{"current_index_$oridcomb"} =  $#{$State{"oridcomb_$oridcomb"}};

	$State{orid} = ${$State{"oridcomb_$oridcomb"}}[$State{"current_index_$oridcomb"}];

	set_dbpick_orid();


	return;
}

sub bind_widgets {
 
 	my( @nooption_widgets ) = qw( fw nw pw fa na pa fe ne pe le 
				      dw swd swa swda tfit sfit rec 
				      tse Fe ae  );
 
 	foreach $command ( @nooption_widgets ) {
 		
 		eval "sub $command { send_to_dbpick( \"$command\" ); }";	
 	}
 
 	my( @onoff_commands ) = qw( sw sa soa sf sd sas );
 
 	foreach $command ( @onoff_commands ) {
 		
 		eval "sub $command\_on { send_to_dbpick( \"$command on\" ); }";	
 		eval "sub $command\_off { send_to_dbpick( \"$command off\" ); }";	
 
 		push( @onoff_widgets, "$command\_on" );
 		push( @onoff_widgets, "$command\_off" );
 	}
 
 	my( @custom_widgets ) = qw( start_dbpick
 			            kill_dbpick
				    start_dbe
				    start_dbxcor
				    channels
 			            exec_spgram
 			            show_predicted
 			            default_phase
				    dbxcor
				    cts
				    mg
				    gp
				    sw
				    pal
				    np
				    pp
 			            );
 
 	my( @bindings ) = ( @nooption_widgets,
 		            @onoff_widgets,
 		            @custom_widgets
 		            );
 
 	foreach $binding ( @bindings ) {
 
 		if( defined( $State{widgets}->{$binding} ) ) {
 
 			$State{widgets}->{$binding}->configure( 
						-command => \&$binding );
 		}
 	}
 
 	foreach $widget ( keys %{$State{widgets}} ) {
 
 		if( $widget =~ /^(group)_(.*)$/ ) {
 
 			my( $group ) = $2;
 
			my( $cmd ) = $widget;
			$cmd =~ s/-/_/g;

 			eval "sub $cmd { show_group( \"$group\" ); }";	
 
 			$State{widgets}->{$widget}->configure( 
						-command => \&$cmd );

 		} elsif( $widget =~ /^(groups)_(.*)$/ ) {

			eval "sub $widget { 
				show_group( \"\$State{var}->{$widget}\" ); 
				}";

 			$State{widgets}->{$widget}->configure( 
						-command => \&$widget );

		} elsif( $widget =~ /^(dbxcor)_(.*)$/ && $widget ne "dbxcor_appname" ) {
 
 			my( $phase ) = $2;
 
			my( $cmd ) = $widget;
			$cmd =~ s/-/_/g;

 			eval "sub $cmd { process_dbxcor_phase( \"$phase\" ); }";	
 
 			$State{widgets}->{$widget}->configure( 
						-command => \&$cmd );

 		} elsif( $widget =~ /^(first)_(.*)$/ ) {

			my( $oridcomb ) = $2;

			my( $cmd ) = $widget;
			$cmd =~ s/-/_/g;

 			eval "sub $cmd { first_special( \"$oridcomb\" ); }";	
 
 			$State{widgets}->{$widget}->configure( 
						-command => \&$cmd );

 		} elsif( $widget =~ /^(next)_(.*)$/ ) {

			my( $oridcomb ) = $2;

			my( $cmd ) = $widget;
			$cmd =~ s/-/_/g;

 			eval "sub $cmd { next_special( \"$oridcomb\" ); }";	
 
 			$State{widgets}->{$widget}->configure( 
						-command => \&$cmd );

 		} elsif( $widget =~ /^(previous)_(.*)$/ ) {

			my( $oridcomb ) = $2;

			my( $cmd ) = $widget;
			$cmd =~ s/-/_/g;

 			eval "sub $cmd { previous_special( \"$oridcomb\" ); }";	
 
 			$State{widgets}->{$widget}->configure( 
						-command => \&$cmd );

 		} elsif( $widget =~ /^(last)_(.*)$/ ) {

			my( $oridcomb ) = $2;

			my( $cmd ) = $widget;
			$cmd =~ s/-/_/g;

 			eval "sub $cmd { last_special( \"$oridcomb\" ); }";	
 
 			$State{widgets}->{$widget}->configure( 
						-command => \&$cmd );
		}
 	}
 
	my( @entry_vars ) = qw( tw 
				ts 
				tc
				cm
				cw
				orid 
				dbname 
				appname 
				dbxcor_appname 
				num_nearby_stations );

	foreach $var ( @entry_vars ) {

 		if( defined( $State{widgets}->{$var} ) ) { 
 
 			$State{widgets}->{$var}->configure( 
					-textvariable => \$State{$var} );
 		}
	}
 
	my( @command_vars ) = qw( tw ts tc cm cw orid );

	foreach $var ( @command_vars ) {

 		if( defined( $State{widgets}->{$var} ) ) { 
			
			my( $cmd ) = "set_dbpick_$var"; 

			$State{widgets}->{$var}->bind( "<Return>", \&$cmd );
 		}
	}
 
	return;
}

sub toplevel_bindings {
	my( $w ) = @_;

	$w->bind( "<Control-c>", \&quit_smartpick );
	$w->bind( "<Control-C>", \&quit_smartpick );

	return;
}
 
$Program = $0 ; 
$Program =~ s".*/"" ;

$State{pf} = $Program;

if ( @ARGV < 1 ) { 

    	die ( Usage() ); 

} else {

	parse_command_line( @ARGV );
}

my $sigset = POSIX::SigSet->new();
my $action = POSIX::SigAction->new('quit_smartpick',
		 $sigset, &POSIX::SA_NODEFER);
POSIX::sigaction(&POSIX::SIGTERM, $action);
POSIX::sigaction(&POSIX::SIGINT, $action);

@booleans = qw( dbpick_command_iconified
		unmap_menubar 
		balloon_help
		auto_dw
		auto_sw_on
		autolaunch_dbxcor
		);

foreach $param ( @booleans ) {
	
	$State{$param} = pfget_boolean( $State{pf}, "$param" );

	if( $State{$param} =~ /^([01-]+)$/ ) {

		$State{$param} = $1;

	} else {

		elog_die( "Parameter-file value '$param' of " .
			  "'$State{$param}' contains unexpected " .
			  "characters. Bye.\n" );
	}
}

%params = qw( dbpick_command_geometry 	[[:alnum:]_\-+]*
	      dbpick_geometry  		[[:alnum:]_\-+]*
	      dbpick_options 		[[:alnum:]_\-+]*
	      smartpick_geometry 	[[:alnum:]_\-+]*
	      smartpick_fontsize 	[[:alnum:]]*
	      path			/[[:alnum:]_/:.\-]+
	      shell			/[[:alnum:]_/]+/(tc|c|ba|k)?sh
	      print_command		[[:alnum:]_/:.]+
	      default_postscript_file	[[:alnum:]_/:.]+
	      default_snapshot_file	[[:alnum:]_/:.]+
	      dbxcor_log_file		[[:alnum:]_/:.]+
	      num_nearby_stations	[[:digit:]]+
	      overlay_time_correction	[[:digit:]\.\+-]+
	      stations_frame_columns	[[:digit:]]+
	      stations_frame_subset	.*
	      );

foreach $param ( keys %params ) {
	
	$State{$param} = pfget( $State{pf}, "$param" );

	$State{$param} =~ s/^\s*//;
	$State{$param} =~ s/\s*$//;

	if( $State{$param} =~ /^($params{$param})$/ ) {

		$State{$param} = $1;

	} else {

		elog_die( "Parameter-file value for '$param' " .
			  "of '$State{$param}' contains unexpected " .
			  "characters. Bye.\n" );
	}
}

init_database();

$ENV{'SHELL'} = $State{shell};
$ENV{'PATH'} = $State{path};

$State{snapshots_possible} = 1;

my( @required ) = @{pfget( $State{pf}, "required_programs" )};

foreach $program ( @required ) {

	if( $program =~ /^[[:alnum:]]*$/ ) {

		if( ! check_for_executable( $program ) ) {

			if( $program eq "import" ) {

				$State{snapshots_possible} = 0;

				next;

			} else {
		
				elog_die( "Couldn't find the '$program' executable " .
					"on path. Please check the 'path' parameter " .
					"in $State{pf}.pf. Bye.\n" );
			}
		}

	} else {
	
		elog_die( "Parameter-file required_programs table " .
			"contains unexpected characters in '$program'. Bye.\n" );
	}
}

my( @crunch ) = @{pfget( $State{pf}, "crunch_on_exit" )};

foreach $table ( @crunch ) {

	if( $table =~ /^[[:alnum:]]*$/ ) {

		push( @{$State{crunch_on_exit}}, $table );
	}
}

if( defined( $State{geom} ) ) {

	# Force the command-line to override the parameter file: 

	$State{dbpick_geometry} = $State{geom};
}

$State{groups} = pfget( $State{pf}, "groups" );

foreach $group ( keys %{$State{groups}} ) {

	if( $State{groups}->{$group} =~ /^([[:alnum:][:space:]<>=~\|\&\/,:_\*\.\-\[\]\(\)]+)$/ ) {
		
		$State{groups}->{$group} = $1;

	} else {
	
		elog_complain( "Parameter-file group '$group' " .
			"(\"$State{groups}->{$group}\") " .
			"contains unexpected characters. Skipping.\n" );
	}
}

foreach $group ( keys %{$State{network_stations}} ) {

	if( ! defined( $State{groups}->{$group} ) ) {

		$State{groups}->{$group} = "net($group)";
	}
}

$State{channels} = pfget( $State{pf}, "channels" );

foreach $channel ( keys %{$State{channels}} ) {

	if( $State{channels}->{$channel} =~ /^([[:alnum:]:_*.-\[\]\(\)]*)$/ ) {
		
		$State{channels}->{$channel} = $1;

	} else {
	
		elog_complain( "Parameter-file channel '$channel' " .
			       "(\"$State{channels}->{$channel}\") " .
			       "contains unexpected characters. Skipping.\n" );
	}
}

my @specs = @{pfget($State{pf},"layout")}; 

map { 
	
	if( $_ =~ m@^([^/]*)$@ ) {
		
		$_ = $1;

	} else {
		
		elog_die( "Layout table entry '$_' contains unexpected " .
			  "characters. Bye.\n" );
	}

	if( $_ =~ m@^(\s*optionmenu\s+channels\s+.*)<auto>(.*)@ ) {

		$_ = $1 . join( " ", sort( keys( %{$State{channels}} ) ) ) . $2;
	}

	while( $_ =~ m@^(\s*optionmenu\s+groups.*)<nettype\s+([a-z]+)>(.*)@ ) {

		if( defined( $State{nettype_networks}->{$2} ) ) { 

			$_ = $1 . join( " ", @{$State{nettype_networks}->{$2}} ) . $3;

		} else {
			
			$_ = $1 . $3;
		}
	}

    } @specs;

Tk::CmdLine::SetArguments( "-title", "smartpick" );

( $MW ) = init_windows( @specs );

bind_widgets();

toplevel_bindings( $MW );

$MW->geometry( $State{smartpick_geometry} );

if( $State{nowait} || $State{autolaunch_dbxcor} ) {

	start_dbpick();
}

if( $State{autolaunch_dbxcor} ) {

	start_dbxcor();
}

$MW->update();

$MW->afterIdle( \&freeze_size );

MainLoop;
